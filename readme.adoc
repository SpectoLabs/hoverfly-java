== Hoverfly JUnit Rule

image:https://circleci.com/gh/SpectoLabs/hoverfly-junit.svg?style=shield["CircleCI", link="https://circleci.com/gh/SpectoLabs/hoverfly-junit"] image:https://img.shields.io/codecov/c/github/spectolabs/hoverfly-junit.svg["Codecov", link="https://codecov.io/gh/spectolabs/hoverfly-junit"] image:https://img.shields.io/maven-central/v/io.specto/hoverfly-junit.svg["Maven Central", link="https://mvnrepository.com/artifact/io.specto/hoverfly-junit"]

A Java native language binding for http://hoverfly.io/[Hoverfly^], which allows you to simulate http services in your unit tests.

=== Legacy schema migration
If you have recorded data in the legacy schema generated before hoverfly-junit 0.1.9, you will need to run these commands using http://hoverfly.io/[Hoverfly^] to migrate to new schema:
```bash
$ hoverctl start
$ hoverctl delete simulations
$ hoverctl import --v1 path-to-my-json/file.json
$ hoverctl export path-to-my-json/file.json
$ hoverctl stop
```

=== Quick-start

Simply add the following rule to your class, giving it the path to your Simulation on the ClassPath.

[source,java,indent=0]
----
@Rule
public HoverflyRule hoverflyRule = HoverflyRule.inSimulationMode("test-service.json");
----


The rule will attempt to detect the operating system and architecture type of the host, and then extract and execute the correct hoverfly binary.  It will import the json into it's database and then and destroy the process at the end of the tests.

=== Maven

You can get the rule from Maven Central

```xml
<groupId>io.specto</groupId>
<artifactId>hoverfly-junit</artifactId>
<version>0.2.2</version>
```

=== Performance

You can boot Hoverfly once and share it across multiple tests by using a `@ClassRule`.

[source,java,indent=0]
----
@ClassRule
public static HoverflyRule hoverflyRule = HoverflyRule.inSimulationMode("test-service.json");
----

=== Simulation Data Schema

Hoverfly simulations are stored as JSON with the http://hoverfly.io/[Hoverfly Schema^].

You can import from the ClassPath:

[source,java,indent=0]
----
@Rule
public HoverflyRule hoverflyRule = HoverflyRule.inSimulationMode("test-service.json");
----

Or you can import from a URL:

[source,java,indent=0]
----
@Rule
public HoverflyRule hoverflyRule = HoverflyRule.inSimulationMode(webServerUri);
----

=== Ports

The admin and proxy port will default to zero, which means they will be randomized to unused ports. This can be helpful in order to avoid port clashes.
If you want to set them statically you can do so through the fluent builder:

[source,java,indent=0]
----
@Rule
public HoverflyRule hoverflyRule = HoverflyRule.inSimulationMode("test-service.json",
        configs().proxyPort(EXPECTED_PROXY_PORT).adminPort(EXPECTED_ADMIN_PORT));
----

=== Apache Http Client

This doesn't respect JVM system properties for things such as the proxy and truststore settings.  Therefore when you build one you would need to:

[source,java,indent=0]
----
httpClient = HttpClientBuilder.create().useSystemProperties().build();
----

Or on older versions you may need to:

[source,java,indent=0]
----
httpClient = new SystemDefaultHttpClient();
----

=== Capturing

Sometimes, it can be useful to write your tests against the real external dependency, recording it along the way.  Once you're happy, you can swap the real external service for your simulation.  This helps produce quick deterministic tests which are able to run in a sandbox.  Simply specify where you want the simulation to be output, relative to `src/test/resources`

[source,java,indent=0]
----
@Rule
public HoverflyRule hoverflyRule = HoverflyRule.inCaptureMode("recorded-simulation.json");
----